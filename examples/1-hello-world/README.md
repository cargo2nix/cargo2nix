# Hello World

This guide demonstrates how to nixify a vanilla `bin` crate generated by `cargo
new`.

### Nix & Nix Flakes

We assume that you **already** have the [Nix package manager] **installed** on
your machine before we get started.  **You must have [nix flakes] enabled**.
Flakes are still relatively new, but it is highly recommended to use nix with
flake support even if you are new to nix because of the simplifications and
better guard rails for your workflows.

If you encounter any difficulties with this guide, please run `nix build` in
this directory with the pre-provided `flake.nix`, `flake.lock` and `Cargo.nix`
as these should be completely reproducible and work on most systems.  **File an
issue if this step fails.**

[Nix package manager]: https://nixos.org/nix/
[Nix flakes]: https://serokell.io/blog/practical-nix-flakes

## Overview

These steps show you how to bootstrap & **maintain** both a `Cargo.nix` and nix
flake for your project.

 - Generating the minimal cargo bin project
 - Generating the `Cargo.nix` file
 - Writing a `flake.nix` file to consume the `Cargo.nix` and provide the outputs
   for `nix build` commands
 - Building & using outputs

## Generating the Cargo project

If you don't have cargo installed, you can use nix to enter a shell that has a
Rust toolchain available.  Then just create a default binary crate project.

```bash
nix shell github:oxalica/rust-overlay

cargo new hello-world
# Created binary (application) `hello-world` package
```

Now you have a mostly empty `Cargo.toml` and `src/main.rs` file.

### Generate Cargo.lock

Cargo2nix uses the `Cargo.toml` and `Cargo.lock` files to generate an equivalent
nix expression for building your project (and its dependencies).  Create this
lockfile by either running `cargo build` or `cargo generate-lockfile` to be more
specific.

```bash
cargo generate-lockfile
```


## Generating a Cargo.nix

If you haven't installed cargo2nix, you can run it directly from the flake
definition from github like so:

```bash
nix shell github:cargo2nix/cargo2nix
```

Generate the `Cargo.nix` file

```bash
cargo2nix -f

# Alternatively you can run cargo2nix directly
nix run github:cargo2nix/cargo2nix -- -f
```


The nix expression inside `Cargo.nix` is a function that returns the dependency
graph of your Cargo crate or [crate workspace].

[crate workspace]: https://doc.rust-lang.org/edition-guide/rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html

#### :warning: Keeping Cargo.nix Up to Date :warning:

> Any time that you modify the `Cargo.toml` or `Cargo.lock` file for your
> project, you should always remember to re-run `cargo2nix -f` to update the
> `Cargo.nix` as well.

You will want both `Cargo.lock` and `Cargo.nix` under version control for
reproducibility. (although only providing `Cargo.nix` is sufficient for nix
builds)

## Writing a flake.nix

In order to consume the `Cargo.nix` and provide outputs for `nix build` and
other `nix` commands, you need to write a `flake.nix`

The overally structure of a flake is very simple.  It's a nix expression that
describes `inputs` and `outputs`.  All of the inputs are usually other flakes.
The output paths tell `nix` commands such as `nix develop` and `nix build` what
to use to do their work.

[`flake.nix`]: ./flake.nix

```nix
{
  # inputs is a set, declaring all of the flakes this flake depends on
  inputs = {
    # we of course want nixpkgs to provide stdenv, dependency packages, and
    # various nix functions
    nixpkgs.url = "github:nixos/nixpkgs?ref=release-21.05";
  
    # we need the overlay at cargo2nix/overlay
    cargo2nix.url = "github:cargo2nix/cargo2nix/master";
    
    # we will need a rust toolchain at least to build our project
    rust-overlay.url = "github:oxalica/rust-overlay";
    rust-overlay.inputs.nixpkgs.follows = "nixpkgs";
    rust-overlay.inputs.flake-utils.follows = "flake-utils";
    
    # convenience functions for writing flakes
    flake-utils.url = "github:numtide/flake-utils";
  };

  # outputs is a function that unsurprisingly consumes the inputs
  outputs = { self, nixpkgs, cargo2nix, flake-utils, rust-overlay, ... }:

    # Build the output set for each default system and map system sets into
    # attributes, resulting in paths such as:
    # nix build .#packages.x86_64-linux.<name>
    flake-utils.lib.eachDefaultSystem (system:
    
      # let-in expressions, very similar to Rust's let bindings.  These names
      # are used to express the output but not themselves paths in the output.
      let

        # create nixpkgs that contains rustBuilder from cargo2nix overlay
        pkgs = import nixpkgs {
          inherit system;
          overlays = [(import "${cargo2nix}/overlay")
                      rust-overlay.overlay];
        };

        # create the workspace & dependencies package set
        rustPkgs = pkgs.rustBuilder.makePackageSet' {
          rustVersion = "1.56.1";
          packageFun = import ./Cargo.nix;
        };
        
      in rec {
        # this is the output (recursive) set (expressed for each system)

        # the packages in `nix build .#packages.<system>.<name>`
        packages = {
          # nix build .#hello-world
          # nix build .#packages.x86_64-linux.hello-world
          hello-world = (rustPkgs.workspace.hello-world {}).bin;
        };

        # nix build
        defaultPackage = packages.hello-world;
      }
    );
}
```

### :warning: Adding Flake to Git :warning:

Nix flake commands have a strong assumption that your project is using
git for version control and that the `flake.nix` has been added.

```bash
git add flake.nix

nix flake check
# verifies the flake and generates a flake.lock file

# you want to add this to version control for distributing reproducibility
git add flake.lock
```

### Understanding the Flake Expressions

Again, it's basically just a declaration of inputs and then an outputs function
for consuming those inputs.  For more information, read up on the [flake
schema].  Each output path usually corresponds to a specific nix command that
will use that output.

[flake schema]: https://nixos.wiki/wiki/Flakes#Flake_schema

Occasionally you want to modify how an output is built, and that is why nix
expressions are defined in the nix language and flakes are expressions rather
than just flat declarations like a yaml file.

#### Constructing Nixpkgs

The flake input for nixpkgs needs to be instantiated into an actual nixpkgs.
The [overlays] inject some extras, like the `rust-bin` set of Rust toolchains
and functions like `rustBuilder.makePackageSet'`.  **Note the single quote in
the name!**

[overlays]: https://nixos.wiki/wiki/Overlays

```nix
        pkgs = import nixpkgs {
          inherit system;
          overlays = [(import "${cargo2nix}/overlay")
                      rust-overlay.overlay];
        };
```

#### Constructing the Workspace & Dependencies Set

We use `makePackageSet'` to import our `Cargo.nix` file and build it using the
`"stable"` release channel of Rust. The output of this function is a tree
structure containing the entire dependency graph from our `Cargo.nix`, which we
call `rustPkgs`.

The structure of `rustPkgs` is organized as follows:

```nix
             rustPkgs."unknown".hello-world."0.1.0" { }
#                     ^^^^^^^^^ ^^^^^^^^^^^ ^^^^^^^ ^^^
#                         |          |         |     |
# Source -----------------+          |         |     |
#  - Crates.io URL                   |         |     |
#  - Git repository URL              |         |     |
#  - Alterative registry URL         |         |     |
#  - `unknown` for path deps         |         |     |
#                                    |         |     |
#                Name ---------------+         |     |
#                                              |     |
#                           Version -----------+     |
#                                                    |
#                    Optional build arguments -------+
#                     - `compileMode = "test"`
#                     - `compileMode = "bench"`
#                     - `buildInputs`, `nativeBuildInputs`, etc.
```

We can refer to any crate present in our `Cargo.lock` file using this notation,
and build it if we want.

#### Getting Our Derivations Out of the Workspace Set

Packages from the workspace are also duplicated as a `workspace` set.  Each
output is a function that must be called (see the main `Cargo.nix` for
arguments) to obtain a final derivation.  The derivations contain a `bin`
attribute that is appropriate for installation into a [nix profile].

[nix profile]: https://nixos.org/manual/nix/unstable/package-management/profiles.html

```nix
# this expression is the bin ouput of our sweet derviation
(rustPkgs.workspace.hello-world {}).bin
```

#### The System Argument

`system`, is a string which declares what platform Nix should build this project
for. This is _not_ a [Rust target triple], but rather a [Nix system parameter]
such as `"x86_64-linux"` or `"x86_64-darwin"`.

[Rust target triple]: https://forge.rust-lang.org/release/platform-support.html
[Nix system parameter]: https://nixos.org/nixos/nix-pills/nixpkgs-parameters.html#idm140737319760528

#### The Rust Overlay

The [Rust Overlay] is a flake that provides a Rust toolchain for use as a
dependency during build.  You can use other versions of Rust by setting
`rustVersion` to `1.55.0` for example.  `rustChannel` can also be set.  See the
oxalica Rust Overlay [reference] for a list of all public attributes.

[reference]: https://github.com/oxalica/rust-overlay/blob/master/docs/reference.md
[Rust Overlay]: https://github.com/oxalica/rust-overlay
[handy Nixpkgs overlay for Rust]: https://github.com/oxalica/rust-overlay
[release channels]: https://doc.rust-lang.org/edition-guide/rust-2018/rustup-for-managing-rust-versions.html

## Building

To compile the `hello-world` binary with Nix, simply run:

```bash
nix build
```

This will create a `result-bin` symlink in the current directory with the following
structure:

```bash
ls -al result-bin
/nix/store/bv9ylpmdixrhzqzd1hcd67pzhip3qc9a-crate-hello-world-0.1.0-bin

tree result-bin
result-bin
└── bin
    └── hello-world
```

Running the `hello-world` binary will print the following message to the screen:

```text
$ ./result-bin/bin/hello-world
Hello, world!
```

Awesome! You've just built your first Rust project with Nix using `cargo2nix`.
:tada:

In the next example, we'll take a look at building a more complex Cargo project
with some Crates.io dependencies.
